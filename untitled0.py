# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lVZRXEGQtm7VI6fBtE_gUab8kE8PjF_g
"""

# =============================================
# üêú Ant Colony Optimization (ACO) for TSP
# =============================================

import numpy as np
import matplotlib.pyplot as plt

# ==============================
# üìå GLOBAL PARAMETERS
# ==============================
N_CITIES = 30  # Number of cities
N_ANTS = 30  # Number of ants
N_ITER = 100  # Number of iterations
ALPHA = 1  # Influence of pheromones
BETA = 2  # Influence of visibility (1/distance)
EVAPORATION = 0.5  # Evaporation rate of pheromones
Q = 100  # Amount of pheromone deposited
INIT_PHEROMONE = 0.1  # Initial pheromone valuea

# ==============================
# üìå GENERATING THE CITIES
# ==============================
np.random.seed(42)
cities = np.random.rand(N_CITIES, 2) * 100  # Positions (x, y)

def euclidean_distance(a, b):
    return np.linalg.norm(a - b)

distances = np.array([[euclidean_distance(a, b) for b in cities] for a in cities])
np.fill_diagonal(distances, np.inf)  # No loops

# ==============================
# üìå INITIALIZING PHEROMONES
# ==============================
pheromones = np.full((N_CITIES, N_CITIES), INIT_PHEROMONE)

# ==============================
# üìå ACO ALGORITHM
# ==============================
best_path = None
best_path_length = np.inf

for iteration in range(N_ITER):
    all_paths = []
    all_lengths = []

    for ant in range(N_ANTS):
        # Each ant starts at a random city
        path = [np.random.randint(0, N_CITIES)]
        while len(path) < N_CITIES:
            current = path[-1]
            unvisited = list(set(range(N_CITIES)) - set(path))

            # Transition probabilities
            tau = pheromones[current, unvisited] ** ALPHA
            eta = (1 / distances[current, unvisited]) ** BETA
            probs = tau * eta
            probs /= np.sum(probs)

            # Selecting the next city
            next_city = np.random.choice(unvisited, p=probs)
            path.append(next_city)

        path.append(path[0])  # Returning to the starting point
        length = sum(distances[path[i], path[i+1]] for i in range(N_CITIES))

        all_paths.append(path)
        all_lengths.append(length)

        if length < best_path_length:
            best_path_length = length
            best_path = path

    # Updating pheromones
    pheromones *= (1 - EVAPORATION)
    for path, length in zip(all_paths, all_lengths):
        for i in range(N_CITIES):
            pheromones[path[i], path[i+1]] += Q / length

    # Displaying progress
    if iteration % 10 == 0:
        print(f"Iteration {iteration}: Best Path Length = {best_path_length:.2f}")

# ==============================
# üìå VISUALIZING THE BEST PATH
# ==============================
plt.figure(figsize=(8, 6))
plt.scatter(cities[:, 0], cities[:, 1], c='red', marker='o', label='Cities')
for i in range(len(best_path) - 1):
    plt.plot([cities[best_path[i], 0], cities[best_path[i+1], 0]],
             [cities[best_path[i], 1], cities[best_path[i+1], 1]], 'b-', alpha=0.7)

plt.plot([cities[best_path[-1], 0], cities[best_path[0], 0]],
         [cities[best_path[-1], 1], cities[best_path[0], 1]], 'b-', alpha=0.7, label='Best Path')
plt.legend()
plt.title(f"Best Path Length: {best_path_length:.2f}")
plt.show()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# ==============================
# üìå CHARGEMENT DES DONN√âES
# ==============================
# Chemin vers le fichier CSV
# csv_file = "UK_Cities.csv"  # Remplacez par le chemin vers votre fichier CSV

# Chargement du fichier CSV dans un DataFrame avec le bon s√©parateur
cities_data = pd.read_csv('medium.csv', header=None)

# Debug : Affiche les premi√®res lignes et colonnes pour v√©rifier
print("Aper√ßu des donn√©es :")
print(cities_data.head())

# Nettoyage des noms de colonnes pour supprimer les espaces √©ventuels
# cities_data.columns = cities_data.columns.str.strip()



# Extraction des coordonn√©es des villes (Latitude et Longitude)
cities = cities_data.to_numpy()
N_CITIES = len(cities)

# ==============================
# üìå PARAM√àTRES GLOBAUX
# ==============================
N_ANTS = 60  # Nombre de fourmis
N_ITER = 200  # Nombre d'it√©rations
ALPHA = 1  # Influence des ph√©romones
BETA = 2  # Influence de la visibilit√© (1/distance)
EVAPORATION = 0.5  # Taux d'√©vaporation des ph√©romones
Q = 100  # Quantit√© de ph√©romones d√©pos√©es
INIT_PHEROMONE = 0.1  # Valeur initiale des ph√©romones

# ==============================
# üìå CALCUL DES DISTANCES EUCLIDIENNES
# ==============================
def euclidean_distance(a, b):
    return np.linalg.norm(a - b)

distances = np.array([[euclidean_distance(a, b) for b in cities] for a in cities])
np.fill_diagonal(distances, np.inf)  # Pas de boucle sur soi-m√™me

# ==============================
# üìå INITIALISATION DES PH√âROMONES
# ==============================
pheromones = np.full((N_CITIES, N_CITIES), INIT_PHEROMONE)

# ==============================
# üìå ALGORITHME ACO
# ==============================
best_path = None
best_path_length = np.inf

for iteration in range(N_ITER):
    all_paths = []
    all_lengths = []

    for ant in range(N_ANTS):
        # Chaque fourmi commence dans une ville al√©atoire
        path = [np.random.randint(0, N_CITIES)]
        while len(path) < N_CITIES:
            current = path[-1]
            unvisited = list(set(range(N_CITIES)) - set(path))

            # Calcul des probabilit√©s de transition
            tau = pheromones[current, unvisited] ** ALPHA
            eta = (1 / distances[current, unvisited]) ** BETA
            probs = tau * eta
            probs /= np.sum(probs)

            # S√©lection de la prochaine ville
            next_city = np.random.choice(unvisited, p=probs)
            path.append(next_city)

        # Retour √† la ville de d√©part
        path.append(path[0])
        length = sum(distances[path[i], path[i+1]] for i in range(N_CITIES))

        all_paths.append(path)
        all_lengths.append(length)

        if length < best_path_length:
            best_path_length = length
            best_path = path

    # Mise √† jour des ph√©romones
    pheromones *= (1 - EVAPORATION)
    for path, length in zip(all_paths, all_lengths):
        for i in range(N_CITIES):
            pheromones[path[i], path[i+1]] += Q / length

    # Affichage de la progression
    if iteration % 10 == 0:
        print(f"Iteration {iteration}: Best Path Length = {best_path_length:.2f}")

# ==============================
# üìå VISUALISATION DU MEILLEUR CHEMIN
# ==============================
plt.figure(figsize=(10, 8))
plt.scatter(cities[:, 1], cities[:, 0], c='red', marker='o', label='Villes')  # Longitude et Latitude

# Tracer le chemin optimal
for i in range(len(best_path) - 1):
    plt.plot(
        [cities[best_path[i], 1], cities[best_path[i+1], 1]],
        [cities[best_path[i], 0], cities[best_path[i+1], 0]],
        'b-', alpha=0.7
    )

# Annoter les noms des villes
# for idx, city in enumerate(cities_data['City']):
#     plt.annotate(city, (cities[idx, 1], cities[idx, 0]), fontsize=8)

plt.title(f"Meilleur chemin trouv√© (Longueur : {best_path_length:.2f})")
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.legend()
plt.show()

plt.scatter(cities[:, 1], cities[:, 0], c='red', marker='o', label='Villes')  # Longitude et Latitude
plt.xlabel('Normalized Latitude')
plt.ylabel('Normalized Longitude')
plt.legend()
plt.show()

"""## English Version"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# ==============================
# üìå LOADING DATA
# ==============================
# Path to CSV file
# csv_file = "UK_Cities.csv"  # Replace with the path to your CSV file

# Loading CSV file into a DataFrame with the correct separator
cities_data = pd.read_csv('medium.csv', header=None)

# Debug: Display first rows and columns for verification
print("Data preview:")
print(cities_data.head())

# Clean column names to remove possible spaces
# cities_data.columns = cities_data.columns.str.strip()

# Extract city coordinates (Latitude and Longitude)
cities = cities_data.to_numpy()
NUM_CITIES = len(cities)

# ==============================
# üìå GLOBAL PARAMETERS
# ==============================
NUM_ANTS = 30  # Number of ants
NUM_ITERATIONS = 100  # Number of iterations
ALPHA = 1  # Pheromone influence
BETA = 2  # Visibility influence (1/distance)
EVAPORATION = 0.5  # Pheromone evaporation rate
Q = 100  # Amount of pheromone deposited
INITIAL_PHEROMONE = 0.1  # Initial pheromone value

# ==============================
# üìå CALCULATING EUCLIDEAN DISTANCE
# ==============================
def euclidean_distance(a, b):
    return np.linalg.norm(a - b)

distances = np.array([[euclidean_distance(a, b) for b in cities] for a in cities])
np.fill_diagonal(distances, np.inf)  # No self-loops

# ==============================
# üìå PHEROMONE INITIALIZATION
# ==============================
pheromones = np.full((NUM_CITIES, NUM_CITIES), INITIAL_PHEROMONE)

# ==============================
# üìå ACO ALGORITHM
# ==============================
best_path = None
best_path_length = np.inf

for iteration in range(NUM_ITERATIONS):
    all_paths = []
    all_lengths = []

    for ant in range(NUM_ANTS):
        # Each ant starts from a random city
        path = [np.random.randint(0, NUM_CITIES)]
        while len(path) < NUM_CITIES:
            current = path[-1]
            unvisited = list(set(range(NUM_CITIES)) - set(path))

            # Calculate transition probabilities
            tau = pheromones[current, unvisited] ** ALPHA
            eta = (1 / distances[current, unvisited]) ** BETA
            probabilities = tau * eta
            probabilities /= np.sum(probabilities)

            # Select next city
            next_city = np.random.choice(unvisited, p=probabilities)
            path.append(next_city)

        # Return to starting city
        path.append(path[0])
        length = sum(distances[path[i], path[i+1]] for i in range(NUM_CITIES))

        all_paths.append(path)
        all_lengths.append(length)

        if length < best_path_length:
            best_path_length = length
            best_path = path

    # Update pheromones
    pheromones *= (1 - EVAPORATION)
    for path, length in zip(all_paths, all_lengths):
        for i in range(NUM_CITIES):
            pheromones[path[i], path[i+1]] += Q / length

    # Display progress
    if iteration % 10 == 0:
        print(f"Iteration {iteration}: Best Path Length = {best_path_length:.2f}")

# ==============================
# üìå VISUALIZING THE BEST PATH
# ==============================
plt.figure(figsize=(10, 8))
plt.scatter(cities[:, 1], cities[:, 0], c='red', marker='o', label='Cities')  # Longitude and Latitude

# Plot the optimal path
for i in range(len(best_path) - 1):
    plt.plot(
        [cities[best_path[i], 1], cities[best_path[i+1], 1]],
        [cities[best_path[i], 0], cities[best_path[i+1], 0]],
        'b-', alpha=0.7
    )

# Annotate city names
for idx, city in enumerate(cities_data['City']):
    plt.annotate(city, (cities[idx, 1], cities[idx, 0]), fontsize=8)

plt.title(f"Best path found (Length: {best_path_length:.2f})")
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.legend()
plt.show()